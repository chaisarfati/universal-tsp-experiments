import numpy as np
from lk_heuristic.utils.solver_funcs import solve as lk_solve

# -------------------------
# TSPLIB I/O
# -------------------------
def write_tsplib_file(points: np.ndarray, filepath: str):
    """Write a TSPLIB EUC_2D file from 2D point list (scaled by 100)."""
    with open(filepath, "w") as f:
        f.write("NAME: temp\n")
        f.write("TYPE: TSP\n")
        f.write("COMMENT: Generated by script\n")
        f.write(f"DIMENSION: {len(points)}\n")
        f.write("EDGE_WEIGHT_TYPE: EUC_2D\n")
        f.write("NODE_COORD_SECTION\n")
        for idx, (x, y) in enumerate(points, start=1):
            f.write(f"{idx} {x*100:.6f} {y*100:.6f}\n")
        f.write("EOF\n")


# -------------------------
# LKH SOLVER WRAPPER
# -------------------------
def solve_tsp_with_lkh(points: np.ndarray):
    """
    Call the LKH solver on a temporary .tsp file and return the permutation
    of indices corresponding to 'points'.
    """
    tsp_path = "/tmp/lkh_instance.tsp"
    write_tsplib_file(points, tsp_path)

    best_tour, best_cost = lk_solve(
        tsp_file=tsp_path,
        solution_method="lk1_improve",
        runs=50,
        backtracking=(5, 5),
        reduction_level=4,
        reduction_cycle=4,
        tour_type="path",
        file_name=None,
        logging_level=100
    )

    # Reproject the tour back to [0,1] to map to 'points'
    reprojected = [(round(p.x / 100, 6), round(p.y / 100, 6)) for p in best_tour]
    index_map = { (round(p[0], 6), round(p[1], 6)) : i for i, p in enumerate(points) }
    tsp_order = [index_map[coord] for coord in reprojected]
    return tsp_order


# -------------------------
# PATH COST
# -------------------------
def compute_path_cost(points: np.ndarray, order: np.ndarray) -> float:
    """Compute total Euclidean path length for a given order of points."""
    ordered_points = points[order]
    return np.sum(np.linalg.norm(np.diff(ordered_points, axis=0), axis=1))

